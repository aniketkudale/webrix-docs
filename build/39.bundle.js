(window.webpackJsonp=window.webpackJsonp||[]).push([[39,41],{"7ljp":function(e,t,n){"use strict";n.d(t,"a",(function(){return s})),n.d(t,"b",(function(){return d}));var a=n("cDcd"),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=o.a.createContext({}),b=function(e){var t=o.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=b(e.components);return o.a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},m=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),s=b(n),m=a,d=s["".concat(i,".").concat(m)]||s[m]||u[m]||r;return n?o.a.createElement(d,l(l({ref:t},p),{},{components:n})):o.a.createElement(d,l({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},Jn0D:function(e,t,n){var a=n("LboF"),o=n("Xgdj");"string"==typeof(o=o.__esModule?o.default:o)&&(o=[[e.i,o,""]]);var r={insert:"head",singleton:!1};a(o,r);e.exports=o.locals||{}},V0Qw:function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return b}));var a=n("pVnL"),o=n.n(a),r=n("QILm"),i=n.n(r),l=(n("cDcd"),n("7ljp")),c=n("Kvkj"),p=(n("Jn0D"),{});function b(e){var t=e.components,n=i()(e,["components"]);return Object(l.b)("wrapper",o()({},p,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"<Movable/>")," component can be used to create items that can be move around. As opposed to a draggable element,\nthe ",Object(l.b)("inlineCode",{parentName:"p"},"<Movable/>")," component does not require a source/target configuration. All it does it trigger an event when the user\nmoves it around, passing the mouse position (",Object(l.b)("inlineCode",{parentName:"p"},"x/y"),"), the difference in the coordinates since the beginning of the event\n(",Object(l.b)("inlineCode",{parentName:"p"},"dx/dy"),"), and the difference in the coordinates since the last event (",Object(l.b)("inlineCode",{parentName:"p"},"cx/cy"),")"),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",o()({parentName:"tr"},{align:null}),"Name"),Object(l.b)("th",o()({parentName:"tr"},{align:null}),"Type"),Object(l.b)("th",o()({parentName:"tr"},{align:null}),"Default"),Object(l.b)("th",o()({parentName:"tr"},{align:null}),"Description"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",o()({parentName:"tr"},{align:null}),Object(l.b)("inlineCode",{parentName:"td"},"onBeginMove")),Object(l.b)("td",o()({parentName:"tr"},{align:null}),"func"),Object(l.b)("td",o()({parentName:"tr"},{align:null}),Object(l.b)("inlineCode",{parentName:"td"},"() => null")),Object(l.b)("td",o()({parentName:"tr"},{align:null}),"Specifies a callback to be called when the user begins to move the element")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",o()({parentName:"tr"},{align:null}),Object(l.b)("inlineCode",{parentName:"td"},"onMove")),Object(l.b)("td",o()({parentName:"tr"},{align:null}),"func"),Object(l.b)("td",o()({parentName:"tr"},{align:null}),Object(l.b)("inlineCode",{parentName:"td"},"() => null")),Object(l.b)("td",o()({parentName:"tr"},{align:null}),"Specifies a callback to be continuously called as the user moves the element around. Receives ",Object(l.b)("inlineCode",{parentName:"td"},"x/y/dx/dy/cx/cy")," as arguments (see description above for more info)")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",o()({parentName:"tr"},{align:null}),Object(l.b)("inlineCode",{parentName:"td"},"onEndMove")),Object(l.b)("td",o()({parentName:"tr"},{align:null}),"func"),Object(l.b)("td",o()({parentName:"tr"},{align:null}),Object(l.b)("inlineCode",{parentName:"td"},"() => null")),Object(l.b)("td",o()({parentName:"tr"},{align:null}),"Specifies a callback to be called when the user stops moving the element")))),Object(l.b)("h1",null,"Basic Example"),Object(l.b)(c.d,{file:"components/Movable/BasicExample",mdxType:"Example"}),Object(l.b)("p",null,"In this example you can see how, using the ",Object(l.b)("inlineCode",{parentName:"p"},"onMove"),", we can change the element coordinates based on ",Object(l.b)("inlineCode",{parentName:"p"},"cx/cy"),"."),Object(l.b)("p",null,"Notice that we are using a function to set the state, instead of passing an object directly.\nThis is because the ",Object(l.b)("a",o()({parentName:"p"},{href:"https://reactjs.org/docs/state-and-lifecycle.html#state-updates-may-be-asynchronous"}),"state may be updated asynchronously"),",\nso we cannot rely on the state value for calculating the next position."),Object(l.b)("p",null,"Using a function will give us the previous state as an argument, and we can use that to accurately calculate the\nnext position."),Object(l.b)("h1",null,"Constraint Movement"),Object(l.b)(c.d,{file:"components/Movable/ConstraintMovement",mdxType:"Example"}),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"<Movable/>")," component gives you complete control over the positioning of the element by only passing information\nthrough the event without actually manipulating the element itself.\nThis way you are free to add your own logic and constraints."),Object(l.b)("p",null,"In this example, we ignore the movement of the mouse on the ",Object(l.b)("inlineCode",{parentName:"p"},"x")," axis to constraint the element to the ",Object(l.b)("inlineCode",{parentName:"p"},"y"),"\naxis."),Object(l.b)("h1",null,"Snapping"),Object(l.b)(c.d,{file:"components/Movable/Snapping",mdxType:"Example"}),Object(l.b)("p",null,"Similarly to the previous example, more complex constraints can be applied, like snapping.\nThis can be achieved by applying the following formula to the coordinates of the element:"),Object(l.b)("pre",null,Object(l.b)("code",o()({parentName:"pre"},{className:"language-jsx"}),"const GRID_SIZE = 20;\nMath.round(x / GRID_SIZE) * GRID_SIZE;\n")),Object(l.b)("p",null,"The main difference is that we are no longer updating the state for every event (the user can move\nthe mouse without the object moving with it until it snaps to the next grid line).\nBecause of that, we need to maintain the initial position of the element, and use ",Object(l.b)("inlineCode",{parentName:"p"},"dx/dy"),"\ninstead to get the next position."))}b.isMDXComponent=!0},Xgdj:function(e,t,n){(t=n("JPst")(!1)).push([e.i,'[id*="components-movable"]{height:200px;display:flex;align-items:center;justify-content:center}[id*="components-movable"] .movable-object{user-select:none;background-color:#E43F5A;width:100px;height:100px;cursor:move;position:relative;color:#fff;padding:10px;display:flex;align-items:center;justify-content:center;text-align:center}\n',""]),e.exports=t}}]);